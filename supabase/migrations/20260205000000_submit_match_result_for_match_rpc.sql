-- =============================================================================
-- SUBMIT MATCH RESULT FOR MATCH RPC
-- Allows a participant to register the score for a specific match (e.g. from
-- match detail during the 48h feedback window). Validates participant,
-- no existing result, match ended and within feedback window, then inserts
-- match_result and match_set.
-- =============================================================================

CREATE OR REPLACE FUNCTION submit_match_result_for_match(
  p_match_id UUID,
  p_submitted_by UUID,
  p_winning_team INT,
  p_sets JSONB
)
RETURNS UUID
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_player_id UUID;
  v_is_participant BOOLEAN;
  v_match_exists BOOLEAN;
  v_has_result BOOLEAN;
  v_match_cancelled BOOLEAN;
  v_match_end_utc TIMESTAMPTZ;
  v_match_ended BOOLEAN;
  v_within_48h BOOLEAN;
  v_set_count INT;
  v_set_el JSONB;
  v_team1_total INT := 0;
  v_team2_total INT := 0;
  v_result_id UUID;
  v_i INT;
BEGIN
  -- Caller must be authenticated; player.id = profile.id = auth.uid()
  v_player_id := auth.uid();
  IF v_player_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;

  -- Caller must be submitting as themselves
  IF v_player_id != p_submitted_by THEN
    RAISE EXCEPTION 'Cannot submit score on behalf of another player';
  END IF;

  -- Participant check: must be a joined participant of this match
  SELECT EXISTS(
    SELECT 1 FROM match_participant mp
    WHERE mp.match_id = p_match_id
      AND mp.player_id = p_submitted_by
      AND mp.status = 'joined'
  ) INTO v_is_participant;
  IF NOT v_is_participant THEN
    RAISE EXCEPTION 'Player is not a joined participant of this match';
  END IF;

  -- Match must exist and not be cancelled
  SELECT EXISTS(SELECT 1 FROM match m WHERE m.id = p_match_id),
         COALESCE((SELECT m.cancelled_at IS NOT NULL FROM match m WHERE m.id = p_match_id), TRUE)
  INTO v_match_exists, v_match_cancelled;
  IF NOT v_match_exists OR v_match_cancelled THEN
    RAISE EXCEPTION 'Match not found or cancelled';
  END IF;

  -- No existing result
  SELECT EXISTS(SELECT 1 FROM match_result mr WHERE mr.match_id = p_match_id)
  INTO v_has_result;
  IF v_has_result THEN
    RAISE EXCEPTION 'Match already has a result';
  END IF;

  -- Match must have ended (end time in match timezone < now)
  SELECT
    CASE
      WHEN m.timezone IS NOT NULL THEN
        CASE
          WHEN m.end_time < m.start_time THEN
            timezone(m.timezone, ((m.match_date + INTERVAL '1 day') + m.end_time)::timestamp)
          ELSE
            timezone(m.timezone, (m.match_date + m.end_time)::timestamp)
        END
      ELSE
        (m.match_date + m.end_time)::timestamptz
    END
  INTO v_match_end_utc
  FROM match m
  WHERE m.id = p_match_id;

  v_match_ended := v_match_end_utc < NOW();
  IF NOT v_match_ended THEN
    RAISE EXCEPTION 'Match has not ended yet';
  END IF;

  -- Optional: allow only within 48h feedback window
  v_within_48h := v_match_end_utc > (NOW() - INTERVAL '48 hours');
  IF NOT v_within_48h THEN
    RAISE EXCEPTION 'Score can only be registered within 48 hours after match end';
  END IF;

  -- Validate p_winning_team
  IF p_winning_team IS NULL OR p_winning_team NOT IN (1, 2) THEN
    RAISE EXCEPTION 'winning_team must be 1 or 2';
  END IF;

  -- Validate p_sets: array of 1-5 objects with team1_score, team2_score (non-negative integers)
  IF jsonb_typeof(p_sets) != 'array' THEN
    RAISE EXCEPTION 'sets must be a JSON array';
  END IF;
  v_set_count := jsonb_array_length(p_sets);
  IF v_set_count < 1 OR v_set_count > 5 THEN
    RAISE EXCEPTION 'sets must contain 1 to 5 elements';
  END IF;

  FOR v_i IN 0..(v_set_count - 1) LOOP
    v_set_el := p_sets->v_i;
    IF jsonb_typeof(v_set_el) != 'object' THEN
      RAISE EXCEPTION 'Each set must be an object';
    END IF;
    IF NOT (v_set_el ? 'team1_score' AND v_set_el ? 'team2_score') THEN
      RAISE EXCEPTION 'Each set must have team1_score and team2_score';
    END IF;
    IF (v_set_el->>'team1_score')::INT IS NULL OR (v_set_el->>'team1_score')::INT < 0 OR
       (v_set_el->>'team2_score')::INT IS NULL OR (v_set_el->>'team2_score')::INT < 0 THEN
      RAISE EXCEPTION 'Set scores must be non-negative integers';
    END IF;
    IF (v_set_el->>'team1_score')::INT > (v_set_el->>'team2_score')::INT THEN
      v_team1_total := v_team1_total + 1;
    ELSIF (v_set_el->>'team2_score')::INT > (v_set_el->>'team1_score')::INT THEN
      v_team2_total := v_team2_total + 1;
    END IF;
  END LOOP;

  -- Insert match_result
  INSERT INTO match_result (
    match_id,
    winning_team,
    team1_score,
    team2_score,
    is_verified,
    submitted_by,
    confirmation_deadline
  ) VALUES (
    p_match_id,
    p_winning_team,
    v_team1_total,
    v_team2_total,
    FALSE,
    p_submitted_by,
    NOW() + INTERVAL '24 hours'
  )
  RETURNING id INTO v_result_id;

  -- Insert match_set rows
  FOR v_i IN 0..(v_set_count - 1) LOOP
    v_set_el := p_sets->v_i;
    INSERT INTO match_set (
      match_result_id,
      set_number,
      team1_score,
      team2_score
    ) VALUES (
      v_result_id,
      v_i + 1,
      (v_set_el->>'team1_score')::INT,
      (v_set_el->>'team2_score')::INT
    );
  END LOOP;

  RETURN v_result_id;
END;
$$;

COMMENT ON FUNCTION submit_match_result_for_match(UUID, UUID, INT, JSONB) IS
  'Allows a joined participant to submit the match result for a specific match. Match must have ended and be within the 48h feedback window. Returns the new match_result id.';

GRANT EXECUTE ON FUNCTION submit_match_result_for_match(UUID, UUID, INT, JSONB) TO authenticated;
GRANT EXECUTE ON FUNCTION submit_match_result_for_match(UUID, UUID, INT, JSONB) TO service_role;
