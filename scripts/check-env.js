#!/usr/bin/env node

/**
 * Environment Validation Script
 *
 * Verifies that required environment variables and .env files are set up correctly.
 *
 * Usage: node scripts/check-env.js [--create-template]
 */

const fs = require('fs');
const path = require('path');

const ROOT_DIR = path.resolve(__dirname, '..');
const CREATE_TEMPLATE = process.argv.includes('--create-template');

// ANSI colors
const colors = {
  reset: '\x1b[0m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  cyan: '\x1b[36m',
  dim: '\x1b[2m',
  bold: '\x1b[1m',
};

function log(message, color = 'reset') {
  console.log(`${colors[color]}${message}${colors.reset}`);
}

function logSection(title) {
  console.log();
  log(`â”â”â” ${title} â”â”â”`, 'cyan');
}

// Define required environment variables per app/context
const ENV_REQUIREMENTS = {
  // Root level (affects all apps)
  root: {
    file: '.env',
    required: [],
    optional: ['SUPABASE_PROJECT_ID'],
  },
  // Web app
  web: {
    file: 'apps/web/.env.local',
    required: ['NEXT_PUBLIC_SUPABASE_URL', 'NEXT_PUBLIC_SUPABASE_ANON_KEY'],
    optional: ['SUPABASE_SERVICE_ROLE_KEY'],
  },
  // Mobile app
  mobile: {
    file: 'apps/mobile/.env',
    required: ['EXPO_PUBLIC_SUPABASE_URL', 'EXPO_PUBLIC_SUPABASE_ANON_KEY'],
    optional: ['SENTRY_DSN', 'STRIPE_PUBLISHABLE_KEY'],
  },
};

/**
 * Parse an env file and return key-value pairs
 */
function parseEnvFile(filePath) {
  if (!fs.existsSync(filePath)) {
    return null;
  }

  const content = fs.readFileSync(filePath, 'utf8');
  const vars = {};

  content.split('\n').forEach(line => {
    // Skip comments and empty lines
    if (line.startsWith('#') || !line.trim()) return;

    const match = line.match(/^([^=]+)=(.*)$/);
    if (match) {
      const key = match[1].trim();
      const value = match[2].trim().replace(/^["']|["']$/g, '');
      vars[key] = value;
    }
  });

  return vars;
}

/**
 * Create a template .env file
 */
function createEnvTemplate(config, targetPath) {
  const fullPath = path.join(ROOT_DIR, targetPath);
  const dir = path.dirname(fullPath);

  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }

  let content = `# Environment variables for ${targetPath}\n`;
  content += `# Generated by: npm run check-env -- --create-template\n\n`;

  if (config.required.length > 0) {
    content += '# Required variables\n';
    config.required.forEach(varName => {
      content += `${varName}=\n`;
    });
    content += '\n';
  }

  if (config.optional.length > 0) {
    content += '# Optional variables\n';
    config.optional.forEach(varName => {
      content += `# ${varName}=\n`;
    });
  }

  const templatePath = fullPath.replace('.env', '.env.example');
  fs.writeFileSync(templatePath, content);
  log(`  Created template: ${templatePath.replace(ROOT_DIR + '/', '')}`, 'green');
}

/**
 * Check environment for a specific app/context
 */
function checkEnvironment(name, config) {
  const filePath = path.join(ROOT_DIR, config.file);
  const vars = parseEnvFile(filePath);
  const issues = [];
  const warnings = [];

  if (vars === null) {
    issues.push(`File not found: ${config.file}`);
    return { issues, warnings, vars: {} };
  }

  // Check required variables
  config.required.forEach(varName => {
    if (!vars[varName]) {
      issues.push(`Missing required: ${varName}`);
    } else if (vars[varName].includes('your_') || vars[varName].includes('YOUR_')) {
      warnings.push(`${varName} appears to be a placeholder`);
    }
  });

  // Check optional variables
  config.optional.forEach(varName => {
    if (!vars[varName]) {
      warnings.push(`Optional not set: ${varName}`);
    }
  });

  return { issues, warnings, vars };
}

/**
 * Main execution
 */
function main() {
  log('\nğŸ” Environment Validation\n', 'bold');

  if (CREATE_TEMPLATE) {
    logSection('Creating .env Templates');
    Object.entries(ENV_REQUIREMENTS).forEach(([name, config]) => {
      createEnvTemplate(config, config.file);
    });
    log('\n  âœ“ Templates created! Copy them to actual .env files and fill in values.', 'green');
    process.exit(0);
  }

  let totalIssues = 0;
  let totalWarnings = 0;

  Object.entries(ENV_REQUIREMENTS).forEach(([name, config]) => {
    logSection(`${name.charAt(0).toUpperCase() + name.slice(1)} (${config.file})`);

    const { issues, warnings, vars } = checkEnvironment(name, config);

    if (issues.length === 0 && warnings.length === 0) {
      log('  âœ“ All environment variables configured', 'green');
    } else {
      issues.forEach(issue => {
        log(`  âœ— ${issue}`, 'red');
        totalIssues++;
      });
      warnings.forEach(warning => {
        log(`  âš  ${warning}`, 'yellow');
        totalWarnings++;
      });
    }
  });

  logSection('Summary');

  if (totalIssues === 0 && totalWarnings === 0) {
    log('  âœ“ All environments properly configured! ğŸ‰', 'green');
    process.exit(0);
  } else {
    if (totalIssues > 0) {
      log(`  âœ— ${totalIssues} missing required variable(s)`, 'red');
    }
    if (totalWarnings > 0) {
      log(`  âš  ${totalWarnings} warning(s)`, 'yellow');
    }

    log('\n  ğŸ’¡ Quick fixes:', 'cyan');
    log('     â€¢ Run: npm run check-env -- --create-template', 'dim');
    log('     â€¢ Copy .env.example files to .env and fill in values', 'dim');
    log('     â€¢ Ask a team member for the required values', 'dim');

    process.exit(totalIssues > 0 ? 1 : 0);
  }
}

main();
